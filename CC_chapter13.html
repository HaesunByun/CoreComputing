

<!DOCTYPE html>


<html >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chapter 13. 알고리즘 설계 기법 &#8212; Core Computing_Thinking with Computers</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=12da95d707ffb74b382d" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=12da95d707ffb74b382d" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=12da95d707ffb74b382d" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=12da95d707ffb74b382d" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "HaesunByun/Core-Computing-Ver.2");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "💬 comment");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'CC_chapter13';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 14. 알고리즘 설계 기법 II" href="CC_chapter14.html" />
    <link rel="prev" title="Chapter 12. 가중치 그래프" href="CC_chapter12.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="None"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/logo_cc.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/logo_cc.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    소개
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Core-Computing Ver.2</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="CC_chapter0.html">Chapter 0. 프로그래밍 언어와 파이썬</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter1.html">Chapter 1. 기본자료형과 입출력</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter2.html">Chapter 2. 복합자료형과 제어문</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter3.html">Chapter 3. 모듈과 함수</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter4.html">Chapter 4. 재귀함수</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter5.html">Chapter 5. 클래스와 객체</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter6.html">Chapter 6. 자료구조와 추상화</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter7.html">중간평가</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter8.html">Chapter 8. 알고리즘의 효율성과 탐색</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter9.html">Chapter 9. 정렬 알고리즘</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter10.html">Chapter 10. 트리</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter11.html">Chapter 11. 그래프</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter12.html">Chapter 12. 가중치 그래프</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 13. 알고리즘 설계 기법</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter14.html">Chapter 14. 알고리즘 설계 기법 II</a></li>
<li class="toctree-l1"><a class="reference internal" href="CC_chapter15.html">기말평가</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/CC_chapter13.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 13. 알고리즘 설계 기법</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">분할정복</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tower-of-hanoi">Tower of Hanoi</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">하노이 타워 동작방법</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">하노이 타워 코드</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">합병정렬(Merge Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">합병정렬 알고리즘</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">합병정렬 예제</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">합병정렬 방법</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">합병정렬 visualization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">합병정렬 구현</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">합병정렬의 시간 측정</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">합병정렬의 시간복잡도</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">마무리</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <hr class="docutils" />
<font color='Blue' size="4">
F37.204 컴퓨팅 핵심: 컴퓨터로 생각하기(Core Computing: Thinking with Computers)</font>
<hr class="docutils" />
<div class="tex2jax_ignore mathjax_ignore section" id="chapter-13">
<h1>Chapter 13. 알고리즘 설계 기법<a class="headerlink" href="#chapter-13" title="Permalink to this headline">#</a></h1>
<div class="info admonition">
<p class="admonition-title">학습목표와 기대효과</p>
<ul class="simple">
<li><p>학습목표</p>
<ul>
<li><p>분할정복 기법을 통해 문제를 작은 하위 문제로 나누어 해결하고, 이를 결합하여 전체 문제를 해결하는 방법을 이해한다.</p></li>
<li><p>동적 계획법을 통해 큰 문제를 작은 하위 문제로 나누어 중복 계산을 피하고 효율적으로 문제를 해결하는 방법을 이해한다.</p></li>
<li><p>매 단계에서 최선의 선택을 하는 방법으로 문제를 해결하는 탐욕 알고리즘의 원리를 이해한다.</p></li>
</ul>
</li>
<li><p>기대효과</p>
<ul>
<li><p>복잡한 문제를 효율적으로 해결할 수 있는 능력을 배양할 수 있다.</p></li>
<li><p>중복된 연산을 제거하여 계산 효율성을 크게 향상시키는 알고리즘 설계를 익힐 수 있다.</p></li>
<li><p>복잡한 문제를 간단하고 직관적인 방식으로 해결할 수 있는 능력을 습득할 수 있다.</p></li>
</ul>
</li>
</ul>
</div>
<p><strong>알고리즘 설계 기법</strong>이란 문제를 효율적으로 해결하기 위해 사용하는 다양한 접근 방법을 의미한다. 이번 수업에서는 세가지 알고리즘 설계 기법을 학습해본다.</p>
<div class="section" id="id1">
<h2>분할정복<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>하노이타워를 통해 분할정복의 개념을 이해해보자.</p></li>
<li><p>합병정렬(mergesort)를 통해 분할정복의 개념을 이해해보자.</p></li>
<li><p>분할정복를 통해 문제 해결방법의 효율성(하노이 타워), 계산 속도의 효율성(합병정렬)을 얻을 수 있다.</p></li>
</ul>
<p>실생활에서 겪는 문제들은 크고 복잡하다. 사이즈가 큰 문제들을 그 상태 그대로 해결하기란 매우 어려운 일이다. 이를 위해 커다란 문제를 작은 사이즈로 바꾸어 해결하는 것을 <strong>분할정복</strong>(Divide and Conquer)이라 한다. 즉, 분할정복은 <font color="red"><code class="docutils literal notranslate"><span class="pre">쪼개서</span> <span class="pre">정복하겠다.</span></code></font>라는 의미로, 큰 문제가 단순해질 때까지 작은 문제로 분할하여 각각의 서브문제를 풀고, 그 결과를 합쳐서 큰 문제에 대한 솔루션을 만들고 싶을 때 <code class="docutils literal notranslate"><span class="pre">분할</span> <span class="pre">정복</span></code>이라는 표현을 쓴다.</p>
<p>컴퓨터 사이언스에서 굉장히 자주 언급되는 문제 풀이 방법론 가운데 하나이며, 분할정복을 통해 문제를 해결할 때, <code class="docutils literal notranslate"><span class="pre">문제</span> <span class="pre">해결</span> <span class="pre">방법의</span> <span class="pre">효율성</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">계산</span> <span class="pre">속도</span> <span class="pre">효율성</span></code>을 높일 수 있다.</p>
<p>이번 장에서는 분할정복을 통해 문제를 푸는 두 가지 예제를 들여다 볼 것이다.</p>
<div class="section" id="tower-of-hanoi">
<h3>Tower of Hanoi<a class="headerlink" href="#tower-of-hanoi" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>그 첫 번째 예제는 하노이 타워이다. 한번쯤은 하노이 타워 문제를 해봤을 것이다.</p></li>
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">https://en.wikipedia.org/wiki/Tower_of_Hanoi</a></p></li>
</ul>
<div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/8/8d/Iterative_algorithm_solving_a_6_disks_Tower_of_Hanoi.gif" height=300 style="width:600px;"></div>
<div class="section" id="id2">
<h4>하노이 타워 동작방법<a class="headerlink" href="#id2" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>하노이 타워 문제는 다음과 같다. 세 개의 막대 A, B, C가 있고, 원반이 있다. 원반은 중앙에 구멍이 뚫려 있어서 막대에 꽂아 넣을 수 있다. 그림과 같이 세 개의 원반이 막대 A에 꽂혀 있을 때, 이 원반을 모두 막대 C로 옮기는 문제이다. 단 원반을 옮길 때 아래의 두 가지 규칙을 지켜야한다.</p>
<ol class="arabic simple">
<li><p>한 번에 한 개의 원반만 옮긴다.</p></li>
<li><p>큰 원반이 그보다 작은 원반 위에 위치할 수 없다.</p></li>
</ol>
</li>
<li><p>이 규칙을 따라 막대 A에 있는 원반을 막대 C로 옮길 때 최적(optimal)으로 몇 번 원반을 옮기면 될까? 그리고 그 방법은 무엇일까?</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi1.png" style="width:300px;"></div><ul class="simple">
<li><p>막대 A의 가장 위에 있는 원반을 막대C로 옮긴다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi2.png" style="width:300px;"></div><ul class="simple">
<li><p>막대 A의 가장 위에 있는 원반을 막대B로 옮긴다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi3.png" style="width:300px;"></div><ul class="simple">
<li><p>막대 C의 원반을 막대B로 옮긴다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi4.png" style="width:300px;"></div><ul class="simple">
<li><p>막대 A의 원반을 막대C로 옮긴다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi5.png" style="width:300px;"></div><ul class="simple">
<li><p>막대 B의 가장 위에 있는 원반을 막대A로 옮긴다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi6.png" style="width:300px;"></div><ul class="simple">
<li><p>막대B의 원반을 막대C로 옮긴다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi7.png" style="width:300px;"></div><ul class="simple">
<li><p>마지막으로 막대A의 원반을 막대C로 옮긴다.</p></li>
<li><p>원반 3개를 규칙에 따라 옮기는 횟수는 7번이 최적이다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/hanoi8.png" style="width:300px;"></div><ul class="simple">
<li><p>아래의 링크를 눌러 하노이 타워 게임을 직접 해보자.</p></li>
</ul>
<p><a class="reference external" href="https://www.mathsisfun.com/games/towerofhanoi.html">https://www.mathsisfun.com/games/towerofhanoi.html</a></p>
<div class="tip admonition">
<p class="admonition-title">하노이 타워의 전설</p>
<p>하노이 타워 문제에는 여러가지 전설이 있다. 하노이 타워니까 베트남 하노이에 있을 법도 한데, 전설에 따르면 인도의 어떤 사원에 실제로 타워 모양의 막대가 있고 64개의 원반이 꽂혀있는데 신관들이 규칙에 따라 64개의 원반을 하나씩 하나씩 다 옮기면 지구가 멸망한다라는 말이 있다. (지구 멸망시키기 참 쉽죠잉~)</p>
</div>
<ul class="simple">
<li><p>그렇다면 64개의 원반을 옮기는데 걸리는 기간을 계산해보자.</p></li>
<li><p>3개의 원반을 옮기는 횟수는 7번, 즉 <span class="math notranslate nohighlight">\(2^3-1\)</span>이다. 따라서 64개의 원반을 옮기는 횟수는  <span class="math notranslate nohighlight">\(2^{64}-1\)</span>이다. 1개의 원반을 옮기는데 걸리는 시간이 3초라면 <span class="math notranslate nohighlight">\((2^{64}-1)*3\)</span>초이다.</p></li>
<li><p>이를 계산해보면 55340232221128654845초, 연으로 환산해보면 1754827252065.216년, 약 1조 7천 5백억년 걸린다. 정말 지구가 멸망하고도 남을 기간이다.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">/</span><span class="mi">60</span><span class="o">/</span><span class="mi">60</span><span class="o">/</span><span class="mi">24</span><span class="o">/</span><span class="mi">365</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1754827252065.216
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id3">
<h4>하노이 타워 코드<a class="headerlink" href="#id3" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>하노이 타워의 코드를 살펴보자.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TowerOfHanoi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>n은 원반의 개수이고, 출발지는 ‘A’이고, 목적지는 ‘C’이고, 중간 보조막대는 ‘B’이다.</p></li>
<li><p>코드는 후에 설명하기로 하고, 먼저 실행시켜서 실행결과를 확인해보자.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span> <span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">auxiliary</span> <span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;Move disk 1 from source </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to destination </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
        <span class="k">return</span>

    <span class="n">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">destination</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;Move disk </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> from source </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to destination </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
    <span class="n">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">source</span> <span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">TowerOfHanoi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="c1">#source &#39;A&#39;, Destin &#39;C&#39;, Auxil &#39;B&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Move disk 1 from source A to destination C
Move disk 2 from source A to destination B
Move disk 1 from source C to destination B
Move disk 3 from source A to destination C
Move disk 1 from source B to destination A
Move disk 2 from source B to destination C
Move disk 1 from source A to destination C
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>실행 결과를 보면,</p>
<ul>
<li><p>위 세줄이 막대 A에서 2개의 원반을 막대B로 옮기는 작업이고,</p></li>
<li><p>그리고 가운데 한줄이 막대 A에서 가장 큰 원반을 막대 C로 옮기는 작업이다.</p></li>
<li><p>아래 세줄이 막대 B에서 2개의 원반을 막대 C로 옮기는 작업이다.</p></li>
</ul>
</li>
<li><p><font color='red' size=3>전체 7줄이 막대 A에서 3개의 원반을 막대 C로 옮기는 작업이다.</font></p></li>
</ul>
<ul class="simple">
<li><p>이번에는 원반을 4개로 해보자.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">TowerOfHanoi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Move disk 1 from source A to destination B
Move disk 2 from source A to destination C
Move disk 1 from source B to destination C
Move disk 3 from source A to destination B
Move disk 1 from source C to destination A
Move disk 2 from source C to destination B
Move disk 1 from source A to destination B
Move disk 4 from source A to destination C
Move disk 1 from source B to destination C
Move disk 2 from source B to destination A
Move disk 1 from source C to destination A
Move disk 3 from source B to destination C
Move disk 1 from source A to destination B
Move disk 2 from source A to destination C
Move disk 1 from source B to destination C
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>가운데 줄 <font color="blue"><code class="docutils literal notranslate"><span class="pre">Move</span> <span class="pre">disk</span> <span class="pre">4</span> <span class="pre">from</span> <span class="pre">source</span> <span class="pre">A</span> <span class="pre">to</span> <span class="pre">destination</span> <span class="pre">C</span></code></font>를 기준으로 위쪽 7줄을 보면 <font color='red' size=3> 막대 A에서 3개의 원반을 막대 B로 옮기는 작업이다.</font> 그런데 이 7줄을 자세히 보면 목적지가 막대 C가 아니라 막대 B로 달라졌을 뿐, n이 3일때의 결과와 동일하다.</p>
<ol class="arabic simple">
<li><p>막대 A에서 2개의 원반을 막대 C로 옮기고,</p></li>
<li><p>가운데 한줄이 막대 A에서 가장 큰 원반을 막대 B로 옮긴다.</p></li>
<li><p>그리고 아래 세줄이 막대 C에서 2개의 원반을 막대 B로 옮기는 작업이다.</p></li>
</ol>
</li>
</ul>
<div><font color='red' size=2>Move disk 1 from source A to destination B<br>
Move disk 2 from source A to destination C<br>
Move disk 1 from source B to destination C<br>
Move disk 3 from source A to destination B<br>
Move disk 1 from source C to destination A<br>
Move disk 2 from source C to destination B<br>
Move disk 1 from source A to destination B</font></div>
<font color="blue" size=2>Move disk 4 from source A to destination C<br></font>
<font size=1>
Move disk 1 from source B to destination C<br>
Move disk 2 from source B to destination A<br>
Move disk 1 from source C to destination A<br>
Move disk 3 from source B to destination C<br>
Move disk 1 from source A to destination B<br>
Move disk 2 from source A to destination C<br>
Move disk 1 from source B to destination C<br></font>
<ul class="simple">
<li><p>아래쪽 7줄을 다시 살펴보자. 이 작업은 <font color='red' size=3> 막대 B에서 3개의 원반을 막대 C로 옮기는 작업이다.</font></p></li>
<li><p>마찬가지로 7줄을 자세히 보면 출발지가 막대 B이고 목적지가 막대 C로 달라졌을 뿐, n이 3일때의 결과와 동일하다.</p></li>
</ul>
<div><font size=1>Move disk 1 from source A to destination B<br>
Move disk 2 from source A to destination C<br>
Move disk 1 from source B to destination C<br>
Move disk 3 from source A to destination B<br>
Move disk 1 from source C to destination A<br>
Move disk 2 from source C to destination B<br>
Move disk 1 from source A to destination B</font></div>
<font color="blue" size=2>Move disk 4 from source A to destination C<br></font>
<font color='red' size=2>
Move disk 1 from source B to destination C<br>
Move disk 2 from source B to destination A<br>
Move disk 1 from source C to destination A<br>
Move disk 3 from source B to destination C<br>
Move disk 1 from source A to destination B<br>
Move disk 2 from source A to destination C<br>
Move disk 1 from source B to destination C<br></font>
- 결론은 n이 4일 때 하노이 타워를 푸는 문제와 n이 3일 때 하노이 타워를 푸는 문제는 근본적으로 동일하다. n의 사이즈만 다를뿐 동일한 알고리즘이다.
<ul class="simple">
<li><p>이제 코드로 돌아가서 코드를 살펴보자.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span> <span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;Move disk 1 from source </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to destination </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
        <span class="k">return</span>

    <span class="n">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">destination</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;Move disk </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> from source </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to destination </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
    <span class="n">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">TowerOfHanoi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">)</span> <span class="c1">#source &#39;A&#39;, Destin &#39;C&#39;, Auxil &#39;B&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Move disk 1 from source A to destination C
Move disk 2 from source A to destination B
Move disk 1 from source C to destination B
Move disk 3 from source A to destination C
Move disk 1 from source B to destination A
Move disk 2 from source B to destination C
Move disk 1 from source A to destination C
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>n이 1이면 소스 막대에서 목적지 막대로 옮긴다.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;Move disk 1 from source </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to destination </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
    <span class="k">return</span>
</pre></div>
</div>
<ul class="simple">
<li><p>n이 1이 아닌 경우에는 막대에 들어있는 n개의 원반중에서 n-1개의 원반을 소스에서 중간막대로 옮긴다.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">destination</span> <span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>그러면 하나 남은 가장 큰 원반을 소스 막대에서 목적지 막대로 옮길 수 있다.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="nb">print</span><span class="p">(</span> <span class="sa">f</span><span class="s2">&quot;Move disk </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> from source </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> to destination </span><span class="si">{</span><span class="n">destination</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>이제 중간막대로 옮겨놓았던 n-1개의 원반을 다시 목적지 막대로 옮긴다.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TowerOfHanoi</span><span class="p">(</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">auxiliary</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">source</span> <span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>이제 위의 동작방식을 염두해 두고 다시 하노이 타워 게임을 해보자.</p></li>
</ul>
<p><a class="reference external" href="https://www.mathsisfun.com/games/towerofhanoi.html">https://www.mathsisfun.com/games/towerofhanoi.html</a></p>
<ul class="simple">
<li><p>하노이타워 문제를 해결하는 알고리즘은 7줄로 매우 짧다. 그러나 이 7줄의 코드가 만들어내는 결과는 무지막지하게 복잡하다.</p></li>
<li><p>n을 1만 늘려도 원반을 옮기는 횟수는 2배+1씩 증가한다.</p>
<ul>
<li><p>n=3 —–&gt; <span class="math notranslate nohighlight">\(2^3 - 1 = 7\)</span></p></li>
<li><p>n=4 —–&gt; <span class="math notranslate nohighlight">\(2^4 - 1 = 15\)</span></p></li>
<li><p>n=5 —–&gt; <span class="math notranslate nohighlight">\(2^5 - 1 = 31\)</span></p></li>
</ul>
</li>
<li><p>즉 옮기는 횟수가 exponential하게 증가한다. 그래서 n이 10만 되어도 그 결과가 1023번으로 커진다.</p></li>
<li><p>하노이타워 문제에서 재귀를 사용한 것처럼, 재귀(recusion)는 분할정복과 밀접한 관계가 있다. 우리가 배웠던 재귀는 기본적으로 <font color='red'><code class="docutils literal notranslate"><span class="pre">생각하는</span> <span class="pre">방식에</span> <span class="pre">해당</span></code></font>한다. 분할정복은 <font color='red'><code class="docutils literal notranslate"><span class="pre">문제를</span> <span class="pre">푸는</span> <span class="pre">방법에</span> <span class="pre">해당</span></code></font>된다. 즉, 생각하는 방식을 가져다가 분할정복을 통해 실제로 문제를 푸는데 활용한 것이다. 기본 아이디어는 <strong>커다란 문제를 작은 사이즈로 바꾸는 것</strong>이였다. 원래의 문제가 갖고 있는 본질은 똑같지만 크기만 줄이는 것이다.</p></li>
<li><p>하노이타워 문제를 재귀를 사용하지 않고 반복문을 사용하여 구현할 수도 있다. 그러나 코드를 찾아서 보면 알겠지만 이해하기 정말 힘들다.</p></li>
</ul>
</div>
</div>
<div class="section" id="merge-sort">
<h3>합병정렬(Merge Sort)<a class="headerlink" href="#merge-sort" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>분할정복을 통해 문제를 푸는 두 번째 예제는 합병정렬(병합정렬)이다.</p></li>
<li><p>앞서 봤던 하노이타워 문제는 재귀적(recursive)으로 구현하나, 반복적(iterative)으로 구현하나 계산속도가 똑같다. 둘다 <span class="math notranslate nohighlight">\(2^n - 1\)</span>번 계산해야 하므로 속도의 잇점은 없다.</p></li>
<li><p>그러나 합병정렬의 예제는 분할정복을 사용하면 계산의 속도가 빨라지는 경우이다.</p></li>
</ul>
<div class="section" id="id4">
<h4>합병정렬 알고리즘<a class="headerlink" href="#id4" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>분할(divide): 리스트를 반복적으로 균등한 크기로 2분할하여 모든 길이가 1이 되도록 한다. (데이터의 개수가 홀수인 경우에는 균등하지 않을 수 있다.)</p></li>
<li><p>정복(conquer): 길이가 1인 리스트는 이미 정렬되어 있으므로, 그런 분할된 부분 리스트를 정렬하면서 합병한다. 이러한 합병 과정을 모든 항목이 정렬될 때까지 반복한다.</p></li>
</ul>
</div>
<div class="section" id="id5">
<h4>합병정렬 예제<a class="headerlink" href="#id5" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>합병정렬을 그림으로 따라가보자.</p></li>
<li><p>Step 0</p>
<ul>
<li><p>데이터가 5 2 4 7 1 3 2 6이 있고 오름차순으로 정렬한다고 가정하자.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort1.png" style="width:600px;"></div><ul class="simple">
<li><p>Step 1</p>
<ul>
<li><p>리스트를 균등하게 이등분하여 2개의 리스트로 만든다.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort2.png" style="width:600px;"></div><ul class="simple">
<li><p>Step 2</p>
<ul>
<li><p>각각의 리스트를 균등하게 이등분하여 더 작은 리스트로 만든다.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort3.png" style="width:600px;"></div><ul class="simple">
<li><p>Step 3</p>
<ul>
<li><p>각각의 리스트를 균등하게 이등분하여 더 작은 리스트로 만든다.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort4.png" style="width:600px;"></div><ul class="simple">
<li><p>Step 4</p>
<ul>
<li><p>리스트의 길이가 1이 되면 이등분을 멈춘다.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort5.png" style="width:600px;"></div>
 - 분할된 부분 리스트를 정렬한 후, 하나의 리스트로 합한다.
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort6.png" style="width:600px;"></div><ul class="simple">
<li><p>Step 5</p>
<ul>
<li><p>분할된 부분 리스트를 정렬한 후, 하나의 리스트로 합한다.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort7.png" style="width:600px;"></div><ul class="simple">
<li><p>Step 6</p>
<ul>
<li><p>분할된 부분 리스트를 정렬한 후, 하나의 리스트로 합한다.</p></li>
</ul>
</li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort8.png" style="width:600px;"></div></div>
<div class="section" id="id6">
<h4>합병정렬 방법<a class="headerlink" href="#id6" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>분할된 부분 리스트를 정렬하는 방법은 다음과 같다.</p></li>
<li><p>예를 들어, 1,2,3,6 리스트 A와 2,4,5,7 리스트 B가 있다고 가정하자.</p></li>
<li><p>step1에서는 리스트 A에서 가장 앞 수인 1과 리스트 B의 가장 앞 수인 2를 비교하여 작은 값을 리스트 C에 저장한다.</p></li>
<li><p>step2에서는 리스트 A에서 가장 앞 수인 2와 리스트 B의 가장 앞 수인 2를 비교하여 작은 값을 리스트 C에 저장한다. (수가 같으면 어느 리스트에서 빼도 상관없지만 그림에서는 리스트 B에서 뺐다.)</p></li>
<li><p>이와 같이 두 리스트의 항목을 앞에서부터 하나씩 비교해서 작은 수를 새로운 리스트에 추가하는 작업을 반복한다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort9.png" style="width:600px;"></div></div>
<div class="section" id="visualization">
<h4>합병정렬 visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>다음은 합병정렬을 그래픽으로 보이고 있는 그림이다. (위키피디아 제공)</p></li>
</ul>
<div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" height=300 style="width:600px;"></div></div>
<div class="section" id="id7">
<h4>합병정렬 구현<a class="headerlink" href="#id7" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>합병정렬을 분할정복 방법을 이용하여 해결하는 코드를 구현해보자.</p></li>
<li><p>먼저, 정렬되지 않은 랜덤데이터셋을 만들어보자.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">rand_data</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">data</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">data</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100000</span><span class="p">)</span> <span class="p">)</span>

<span class="n">rand_data</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">rand_data</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">data</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="n">data</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100000</span><span class="p">)</span> <span class="p">)</span>

<span class="n">rand_data</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">StdinNotImplementedError</span><span class="g g-Whitespace">                  </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">5</span><span class="o">-</span><span class="n">a26d2de9b0de</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">8</span>         <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100000</span><span class="p">)</span> <span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span> 
<span class="ne">---&gt; </span><span class="mi">10</span> <span class="n">rand_data</span><span class="p">()</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span> <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="nn">&lt;ipython-input-5-a26d2de9b0de&gt;</span> in <span class="ni">rand_data</span><span class="nt">()</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="k">def</span> <span class="nf">rand_data</span><span class="p">():</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span>     <span class="k">global</span> <span class="n">data</span>
<span class="ne">----&gt; </span><span class="mi">5</span>     <span class="n">n</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span>     <span class="n">data</span><span class="o">=</span><span class="p">[]</span>
<span class="g g-Whitespace">      </span><span class="mi">7</span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>

<span class="nn">D:\users\anaconda3\lib\site-packages\ipykernel\kernelbase.py</span> in <span class="ni">raw_input</span><span class="nt">(self, prompt)</span>
<span class="g g-Whitespace">    </span><span class="mi">853</span>         <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_stdin</span><span class="p">:</span>
<span class="g g-Whitespace">    </span><span class="mi">854</span>             <span class="k">raise</span> <span class="n">StdinNotImplementedError</span><span class="p">(</span>
<span class="ne">--&gt; </span><span class="mi">855</span>                 <span class="s2">&quot;raw_input was called, but this frontend does not support input requests.&quot;</span>
<span class="g g-Whitespace">    </span><span class="mi">856</span>             <span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">857</span>         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_request</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">prompt</span><span class="p">),</span>

<span class="ne">StdinNotImplementedError</span>: raw_input was called, but this frontend does not support input requests.
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>mergeSort(data)는 리스트를 인자로 받아 길이가 1일 될 때까지 분할하는 함수이다. 이 함수에서는 재귀를 사용하여 분할한다.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Divide&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>

        <span class="n">mergeSort</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">mergeList</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">data</span> <span class="p">)</span>

<span class="n">mergeSort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>아래 mergeList() 함수는 정렬된 두 개의 리스트 A와 B를 C로 합치면서 정렬하는 함수이다.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mergeList</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>      <span class="c1"># i, j, k, respectively, are indexes of A, B, C.</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="ow">and</span>  <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Checking if any element was left</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merge&quot;</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id8">
<h4>합병정렬의 시간 측정<a class="headerlink" href="#id8" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>합병정렬의 시간을 측정해보자.</p></li>
<li><p>데이터를 1000개, 10000개, 100000개, 1000000개, 10000000개를 테스트해보자.</p></li>
<li><p>분할과 합병을 하는 순서를 출력하라고 해 놓았으니 주석처리한 후 실행시키도록 하자.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">timeit</span>
<span class="k">def</span> <span class="nf">start</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">startTime</span>
    <span class="n">startTime</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">():</span>
    <span class="n">stopTime</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;Time:&#39;</span><span class="p">,</span> <span class="n">stopTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rand_data</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The input is:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span>

<span class="n">start</span><span class="p">()</span>
<span class="n">mergeSort</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">stop</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The sorted list is: &quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h4>합병정렬의 시간복잡도<a class="headerlink" href="#id9" title="Permalink to this headline">#</a></h4>
<ul class="simple">
<li><p>합병정렬의 시간복잡도를 생각해보자.</p></li>
<li><p>지난 버블정렬, 선택정렬, 삽입정렬의 시간복잡도는 <span class="math notranslate nohighlight">\(O(n^2)\)</span>이였다.</p></li>
<li><p>합병정렬은 이들 알고리즘보다 비할 수 없을정도로 효율적인 알고리즘이다. 컴퓨터분야에서는 알고리즘의 효율성을 놓고 얘기할 때 더 효율적이다 혹은 덜 효율적이다라는 의미는 단순하게 한배 빠르다, 두배 빠르다 이런식의 의미가 아니다. 대부분의 경우에 문제의 결과를 볼 수 있을 정도냐? 아니면 지구가 멸망할 때 까지 결과를 볼 수 없을 정도냐! 이런 정도로 분리가 된다.</p></li>
</ul>
<ul class="simple">
<li><p>합병정렬은 리스트를 반복적으로 2분할하여, 모든 길이가 1이 될 때까지 분할한다. 길이가 1인 리스트는 이미 정렬되어 있다. 그러한 두 개의 정렬된 리스트를 머징하면서 새로운 정렬리스트를 생성한다. 이러한 머징 과정을 모든 항목이 정렬될 때까지 반복한다.</p></li>
</ul>
<p>위키피디아 <a class="reference external" href="https://en.wikipedia.org/wiki/Merge_sort">https://en.wikipedia.org/wiki/Merge_sort</a></p>
<div align="center"><img src="https://haesunbyun.github.io/common/images/mergesort10.png" height='500' style="width:500px;"></div>
<ul class="simple">
<li><p>합병정렬에서는 <strong>머징하는데 들어가는 시간복잡도</strong>는 얼마인지 따져봐야 한다.</p></li>
<li><p>엄밀히 말하면 분할하는데 들어가는 비용도 고려를 하는 것이 맞다. 그러나 분할하는데 들어가는 비용보다 머징하는데 들어가는 비용이 훨씬 크다. 분할에서는 아무것도 하지않고 분할만 하므로 계산량 자체가 분할하는 쪽이 훨씬 적고 머징하는 쪽이 훨씬 많다. 따라서 머징할 때의 시간복잡도를 따진다.</p></li>
<li><p>머징할 때를 생각해보자. 리스트 A의 인덱스 <em>i</em>, 리스트 B의 인덱스 <em>j</em>, 리스트 C의 인덱스 <em>k</em>가 있다. 리스트 A의 항목과 리스트 B의 항목을 한번 비교할 때마다 인덱스 <em>i</em> 또는 <em>j</em>가 한번 전진한다.</p></li>
<li><p>즉, 한 스텝에서 인덱스가 전진하는 총 횟수, 즉 최대비교횟수는 전체 데이터의 개수 n번 뿐이다.</p></li>
<li><p>그래서 한 스텝에서 머징하는데 들어가는 시간복잡도는 데이터의 크기와 같다.</p></li>
<li><p>이때 각각의 스텝마다 리스트의 크기가 서로 다르더라도, 리스트가 아무리 많이 쪼개져도 결국은 n개가 쪼개진 것이므로 데이터의 크기는 n개이다.</p></li>
<li><p>따라서 각 스텝마다 들어가는 시간복잡도는 n이다.</p></li>
<li><p>그런 n개의 시간복잡도를 가진 스텝이 총 몇개 생길까? 리스트의 크기는 한번 분할될때마다 반으로 줄어든다. 따라서 깊이는 <span class="math notranslate nohighlight">\(log_2n\)</span>이다.</p></li>
<li><p>결과적으로 전체 시간복잡도는 <span class="math notranslate nohighlight">\(n*log_2n\)</span>이며, 빅오표기법으로 표기하면 <font color='red'> <span class="math notranslate nohighlight">\(O(n\log n)\)</span></font>이다.</p></li>
</ul>
<ul class="simple">
<li><p>버블정렬, 선택정렬, 삽입정렬의 시간복잡도가 <span class="math notranslate nohighlight">\(O(n^2)\)</span>인것에 비해 합병정렬의 시간복잡도는 <span class="math notranslate nohighlight">\(O(n\log n)\)</span>이다. 이 두개의 시간복잡도는 비교할 수도 없을만큼 큰 차이가 난다.</p></li>
<li><p>지난번 봤던 빅오 시간복잡도 그래프를 소환해서 살펴보자. 아래 그래프는 <span class="math notranslate nohighlight">\(n\)</span>이 증가할 때 시간 복잡도 함수가 얼마나 증가하는지 보여준다.</p></li>
<li><p><span class="math notranslate nohighlight">\(O(n\log n)\)</span>은 <span class="math notranslate nohighlight">\(O(n)\)</span>에 가깝고, 이때 <span class="math notranslate nohighlight">\(O(n)\)</span>은 한없이 상수와 가까운 시간복잡도라고 볼 수 있다.</p></li>
<li><p>따라서 일반적으로 <span class="math notranslate nohighlight">\(O(n\log n)\)</span> 알고리즘은 메모리에 데이터가 올라가는 한도 내에서는 사이즈가 아무리 커져도 전혀 문제없이 해결가능하다.</p></li>
</ul>
<div align="center"><img src="https://haesunbyun.github.io/common/images/search2.png" height=300 style="width:600px;"></div>
<p><a class="reference external" href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></p>
<div class="tip admonition">
<p class="admonition-title">합병정렬 알고리즘</p>
<p>합병정렬 알고리즘은 존 폰 노이만이 1945년에 개발했다. 폰 노이만은 현대 사용하고 있는 컴퓨터와 같은 CPU, 메모리, 프로그램 구조를 갖는 범용 컴퓨터 구조를 최초로 설계/확립한 사람이다. 그래서 컴퓨터공학도들이라면 누구나 알고 있다.
폰 노이만은 합병정렬에서 분할정복 개념을 적용하였는데 이것만 봐도 폰 노이만의 천재성을 알 수 있을 것 같다.</p>
<p>참고로 얘기하면, 정렬 알고리즘의 시간복잡도는 lower bound도 <span class="math notranslate nohighlight">\(O(n\log n)\)</span>이고 upper bound도 <span class="math notranslate nohighlight">\(O(n\log n)\)</span>이다. <span class="math notranslate nohighlight">\(O(n\log n)\)</span> 알고리즘이 현재 최적(optimal) 알고리즘이다.
<span class="math notranslate nohighlight">\(O(n\log n)\)</span>의 성능을 갖는 정렬 알고리즘들로는 합병정렬 알고리즘 이외에도 힙정렬, 퀵정렬, 트리정렬 등의 알고리즘이 있다.</p>
<p>합병정렬 알고리즘은 옵티말 알고리즘이지만 그다지 선호받는 알고리즘은 아니고, 대부분의 프로그래밍 언어에서 구현되어져 알고리즘은 퀵정렬 알고리즘이 사용되고 있다. 퀵정렬 알고리즘은 평균 시간복잡도에서 최고의 성능을 갖는다.</p>
<p><a class="reference external" href="https://namu.wiki/w/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://namu.wiki/w/정렬알고리즘</a></p>
</div>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>마무리<a class="headerlink" href="#id10" title="Permalink to this headline">#</a></h2>
<ul class="simple">
<li><p>분할정복은 큰 문제가 단순해질 때까지 작은 문제로 분할하여 각각의 서브문제를 풀고, 그 결과를 합쳐서 큰 문제에 대한 솔루션을 만드는 문제 풀이 방법론 가운데 하나이다.</p></li>
<li><p>하노이 타워 문제에서는 분할정복을 통해 큰 문제를 작은 문제로 단순화 시켜 해결하는 <code class="docutils literal notranslate"><span class="pre">문제</span> <span class="pre">해결</span> <span class="pre">방법의</span> <span class="pre">효율성</span></code> 측면에서 다뤄보았다.</p></li>
<li><p>합병정렬에서는 리스트를 더 이상 쪼개지지 않을 때까지 분할하여 작게 만들고 머징하면서 정렬하는 방법을 통해 <code class="docutils literal notranslate"><span class="pre">계산</span> <span class="pre">속도의</span> <span class="pre">효율성</span></code> 측면에서 다뤄보았다.</p></li>
<li><p>분할 정복은 여러 알고리즘의 기본이 되는 문제해결 방법으로 이진탐색, 퀵정렬, 행렬곱셈 등에서 분할 정복이 사용된다.</p></li>
<li><p>그러나 분할정복을 사용하면 안되는 문제도 있다. 대표적인 예가  피보나치 수열이다. 피보나치 수열에서는 n이 어떤 수이든 그 하위 수를 구하는 부분이 중복해서 나타난다. 분할 정복은 분할된 하위 문제에서 동일한 중복이 일어나지 않는 경우에만 효율성이 높아진다.</p></li>
</ul>
<hr class="docutils" />
<font color='Grey' size="4">
F37.204 컴퓨팅 핵심: 컴퓨터로 생각하기(Core Computing: Thinking with Computers)</font>
<hr class="docutils" />
<p>서울대학교 학부대학<br>
교수 변해선</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="CC_chapter12.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 12. 가중치 그래프</p>
      </div>
    </a>
    <a class="right-next"
       href="CC_chapter14.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 14. 알고리즘 설계 기법 II</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">분할정복</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tower-of-hanoi">Tower of Hanoi</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">하노이 타워 동작방법</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">하노이 타워 코드</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#merge-sort">합병정렬(Merge Sort)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">합병정렬 알고리즘</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">합병정렬 예제</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">합병정렬 방법</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization">합병정렬 visualization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">합병정렬 구현</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">합병정렬의 시간 측정</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">합병정렬의 시간복잡도</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">마무리</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            <div class="bd-footer-content__inner">
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By hs Byun
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div></div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=12da95d707ffb74b382d"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=12da95d707ffb74b382d"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>